Project File Structure:
./
    .gitignore
    app.py
    config.py
    models.py
    project_structure.txt
    to_do.txt
    __init__.py
    instance/
        recipes.db
    static/
        dynamic_fields.js
        style.css
    templates/
        404.html
        index.html
        recipe_page.html

Contents of ['.py', '.html', '.css', '.js'] Files:

File: .\app.py

from flask import render_template, request, jsonify
from config import app, db
from models import Recipe, Ingredient

@app.route('/', methods=['GET'])
def index():
    min_rating = request.args.get('minRating', 0.5, type=float)
    min_rating_count = request.args.get('minRatingCount', 0, type=int)
    sort_option = request.args.get('sortOption', 'name')
    query_param = request.args.get('query', '')

    # Modify query based on filters, sorting, and search query
    query = Recipe.query
    if min_rating:
        query = query.filter(Recipe.rating >= min_rating)
    if min_rating_count:
        query = query.filter(Recipe.rating_count >= min_rating_count)
    if sort_option == 'rating':
        query = query.order_by(Recipe.rating.desc(), Recipe.name)
    else:
        query = query.order_by(Recipe.name)

    # Filter recipes based on search query if provided
    if query_param:
        query = query.filter(Recipe.name.contains(query_param) |
                             Recipe.ingredients.any(Ingredient.name.contains(query_param)))

    recipes = query.all()

    # Check for AJAX request
    if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
        return render_template('partials/recipe_grid.html', recipes=recipes)

    return render_template('index.html', recipes=recipes)

@app.route('/search', methods=['GET'])
def search():
    query = request.args.get('q', '')
    if query:
        ingredient_list = Ingredient.query.with_entities(Ingredient.name).filter(
            Ingredient.name.contains(query)).distinct().all()
        recipe_list = Recipe.query.with_entities(Recipe.name).filter(Recipe.name.contains(query)).distinct().all()
        suggestions = [ingredient.name for ingredient in ingredient_list] + [recipe.name for recipe in recipe_list]
        return jsonify(suggestions)
    return jsonify([])

@app.route('/recipe-page', methods=['GET'])
def recipe_page():
    recipe_id = request.args.get('recipe', '')
    if recipe_id:
        recipe = Recipe.query.get(recipe_id)
        if recipe:
            return render_template('recipe_page.html', recipe=recipe)
    return render_template('404.html')  # Template for page not found

if __name__ == '__main__':
    app.run(debug=True)



File: .\config.py

from flask import Flask
from flask_sqlalchemy import SQLAlchemy

app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///recipes.db'
db = SQLAlchemy(app)


File: .\models.py

from config import db

class Recipe(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), nullable=False)
    link = db.Column(db.String(255))
    time_prepare = db.Column(db.String(50))
    time_wait = db.Column(db.String(50))
    rating = db.Column(db.Float)
    rating_count = db.Column(db.Integer)
    tags = db.Column(db.String(255))
    servings = db.Column(db.String(50))
    ingredients = db.relationship('Ingredient', backref='recipe', lazy=True)
    steps = db.relationship('RecipeStep', backref='recipe', lazy=True)
    equipment = db.Column(db.String(255))
    image = db.Column(db.String(255))

class Ingredient(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), nullable=False)
    amount = db.Column(db.String(50))
    recipe_id = db.Column(db.Integer, db.ForeignKey('recipe.id'), nullable=False)

class RecipeStep(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    step = db.Column(db.Text, nullable=False)
    recipe_id = db.Column(db.Integer, db.ForeignKey('recipe.id'), nullable=False)
    order = db.Column(db.Integer)  # To maintain the order of steps


File: .\__init__.py

import os
import shutil
from app import app
from models import db

def delete_instance_folder(path='instance'):
    if os.path.exists(path):
        shutil.rmtree(path)

def create_directory_for_db(path='instance'):
    if not os.path.exists(path):
        os.makedirs(path)

with app.app_context():
    # Delete the instance folder
    delete_instance_folder()

    # Create the necessary directory for the SQLite database
    create_directory_for_db()
    # Recreate the database
    db.create_all()
    # Import and run the import_recipes script
    from recipe_scraper.import_recipes import main as import_recipes_main
    import_recipes_main()



File: .\static\dynamic_fields.js

document.addEventListener('DOMContentLoaded', function() {
    let searchInput = document.getElementById('quickSearchInput');
    let searchButton = document.getElementById('searchButton');
    let minRatingCountInput = document.getElementById('minRatingCount');
    let sortOptionSelect = document.getElementById('sortOption');

    searchInput.addEventListener('input', event => fetchSuggestions(event.target));
    searchButton.addEventListener('click', () => performSearch(searchInput.value));
    minRatingCountInput.addEventListener('change', () => updateSearchResults());
    sortOptionSelect.addEventListener('change', () => updateSearchResults());

    searchInput.addEventListener('keypress', function (e) {
        if (e.key === 'Enter') {
            e.preventDefault();
            performSearch(searchInput.value);
        }
    });

    document.addEventListener("click", e => closeAllLists(e.target));
});

function updateSearchResults() {
    let searchTerm = document.getElementById('quickSearchInput').value;
    let minRatingCount = document.getElementById('minRatingCount').value;
    let sortOption = document.getElementById('sortOption').value;

    let searchParams = new URLSearchParams({
        q: searchTerm,
        minRatingCount: minRatingCount,
        sortOption: sortOption
    });

    let gridContainer = document.getElementById('searchResults');
    gridContainer.innerHTML = '<div class="loader"></div>';

    fetch('/?' + searchParams.toString())
        .then(response => response.text())
        .then(html => {
            let parser = new DOMParser();
            let doc = parser.parseFromString(html, 'text/html');
            let newResults = doc.getElementById('searchResults');
            let currentResults = document.getElementById('searchResults');
            currentResults.innerHTML = newResults.innerHTML;
        })
        .catch(error => console.error('Error updating search results:', error));
}

function fetchSuggestions(inputElement) {
    let searchTerm = inputElement.value;
    if (searchTerm.length < 1) return closeAllLists();

    fetch('/search?q=' + encodeURIComponent(searchTerm))
        .then(response => response.json())
        .then(suggestions => showSuggestions(inputElement, suggestions))
        .catch(error => console.error('Error fetching suggestions:', error));
}

function showSuggestions(inputElement, suggestions) {
    closeAllLists();
    if (!suggestions.length) return;

    let list = createList(inputElement);
    suggestions.forEach(suggestion => createListItem(inputElement, list, suggestion));
}

function createList(inputElement) {
    let list = document.createElement("DIV");
    list.setAttribute("id", inputElement.id + "autocomplete-list");
    list.setAttribute("class", "autocomplete-items");
    list.style.position = 'absolute';
    list.style.left = inputElement.getBoundingClientRect().left + 'px';
    list.style.top = (inputElement.getBoundingClientRect().top + inputElement.offsetHeight) + 'px';
    document.body.appendChild(list);
    return list;
}

function createListItem(inputElement, list, suggestion) {
    let item = document.createElement("DIV");
    item.innerHTML = highlightTerm(inputElement.value, suggestion);
    item.addEventListener("click", () => {
        inputElement.value = suggestion; // Set input value to the clicked suggestion
        performSearch(suggestion);
        closeAllLists();
    });
    list.appendChild(item);
}

function highlightTerm(term, text) {
    return text.replace(new RegExp("(" + term + ")", "gi"), "<strong>$1</strong>");
}

function closeAllLists(elmnt) {
    let items = document.getElementsByClassName("autocomplete-items");
    for (let i = 0; i < items.length; i++) {
        if (elmnt != items[i]) items[i].parentNode.removeChild(items[i]);
    }
}

// Add the updated performSearch function
function performSearch(searchTerm) {
    if (searchTerm.length > 0) {
        let searchParams = new URLSearchParams({
            query: searchTerm,
            sortOption: 'name' // Default sort by name
        });
        fetch('/?' + searchParams.toString())
            .then(response => response.text())
            .then(html => {
                let parser = new DOMParser();
                let doc = parser.parseFromString(html, 'text/html');
                let newResults = doc.getElementById('searchResults');
                let currentResults = document.getElementById('searchResults');

                // Add animation here
                currentResults.style.opacity = 0;
                setTimeout(() => {
                    currentResults.innerHTML = newResults.innerHTML;
                    currentResults.style.opacity = 1;
                }, 500); // Adjust time for desired animation effect
            })
            .catch(error => console.error('Error fetching search results:', error));
    }
    closeAllLists();
}




File: .\static\style.css

/* General body styling */
body {
    font-family: Arial, sans-serif;
    background-color: #f4f4f4;
    margin: 0;
    padding: 0;
}

/* Style for the main container */
.container {
    width: 80%;
    margin: auto;
    overflow: hidden;
    padding: 20px;
}

/* Style for search container */
.search-container {
    margin-bottom: 20px;
    text-align: center;
}

.search-container input[type="text"] {
    padding: 10px;
    margin-right: 10px;
    width: 300px;
    border: 1px solid #ccc;
    border-radius: 4px;
}

.search-container button {
    padding: 10px 20px;
    background-color: #5cb85c;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
}

.search-container button:hover {
    background-color: #4cae4c;
}

/* Style for filter and sort controls */
.filter-sort-container {
    display: flex;
    justify-content: center;
    align-items: center;
    margin-bottom: 20px;
}

.filter-container, .sort-container {
    margin: 0 10px;
}

/* Style for the recipe grid */
.grid-container {
    display: grid;
    grid-template-columns: repeat(3, 1fr); /* 3 columns */
    gap: 10px;
}

.grid-item {
    background-color: #ffffff;
    border: 1px solid #ddd;
    padding: 10px;
    text-align: center;
    text-decoration: none;
    color: black;
}

.grid-item:hover {
    transform: scale(1.02); /* Reduced scale for less intense effect */
    box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.1);
    transition: transform 0.3s ease, box-shadow 0.3s ease; /* Faster transition */
}

.recipe-image img {
    max-width: 100%;
    height: auto;
}

.recipe-details h3 {
    margin-top: 0;
}

/* Style for autocomplete dropdown */
.autocomplete-items {
    border: 1px solid #d4d4d4;
    border-bottom: none;
    border-top: none;
    z-index: 99;
    /* position the autocomplete items to be the same width as the container */
    top: 100%;
    left: 0;
    right: 0;
}

.autocomplete-items div {
    padding: 10px;
    cursor: pointer;
    background-color: #fff;
    border-bottom: 1px solid #d4d4d4;
}

/* When hovering an item */
.autocomplete-items div:hover {
    background-color: #e9e9e9;
}

/* When navigating through the items using the arrow keys */
.autocomplete-active {
    background-color: DodgerBlue !important;
    color: #ffffff;
}

.loader {
    border: 5px solid #f3f3f3; /* Light grey border */
    border-top: 5px solid #3498db; /* Blue border */
    border-radius: 50%;
    width: 50px;
    height: 50px;
    animation: spin 1s linear infinite;
    margin: 20px auto; /* Center in the container */
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

/* Adjust the height of the grid container to accommodate the loader */
.grid-container {
    min-height: 200px; /* Adjust as needed */
}


/* Responsive adjustments */
@media (max-width: 600px) {
    .grid-container {
        grid-template-columns: 1fr; /* 1 column for small screens */
    }
}


File: .\templates\404.html

<!DOCTYPE html>
<html>
<head>
    <title>Recipe Not Found</title>
    <link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='style.css') }}">
</head>
<body>
    <div class="container">
        <h1>Recipe Not Found</h1>
        <p>The recipe you are looking for does not exist.</p>
        <a href="/">Back to search</a>
    </div>
</body>
</html>



File: .\templates\index.html

<!DOCTYPE html>
<html>
<head>
    <title>Recipe Search</title>
    <link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='style.css') }}">
    <script src="{{ url_for('static', filename='dynamic_fields.js') }}"></script>
</head>
<body>
    <div class="container">
        <!-- Search Container -->
        <div class="search-container">
            <input type="text" id="quickSearchInput" placeholder="Search recipes or ingredients" class="ingredientInput" autocomplete="off">
            <button id="searchButton">Search</button>
        </div>

        <!-- Filter and Sorting Controls -->
        <div class="filter-sort-container">
            <div class="sort-container">
                <label for="sortOption">Sort by:</label>
                <select id="sortOption">
                    <option value="rating">Rating</option>
                    <option value="name">Name</option>
                </select>
            </div>

            <div class="filter-container">
                <label for="minRatingCount">Minimum Rating Count:</label>
                <input type="number" id="minRatingCount" min="0" value="0" style="width: 60px;">
            </div>
        </div>

        <!-- Search Results Grid -->
        <div id="searchResults" class="grid-container">
            {% for recipe in recipes %}
                <a href="/recipe-page?recipe={{ recipe.id }}" class="grid-item">
                    <div class="recipe-image">
                        {% if recipe.image %}
                            <img src="{{ recipe.image }}" alt="{{ recipe.name }}">
                        {% endif %}
                    </div>
                    <div class="recipe-details">
                        <h3>{{ recipe.name }}</h3>
                        <p>Rating: {{ recipe.rating | default('N/A') }} ({{ recipe.rating_count | default('0') }})</p>
                    </div>
                </a>
            {% endfor %}
        </div>
    </div>
</body>
</html>


File: .\templates\recipe_page.html

<!DOCTYPE html>
<html>
<head>
    <title>{{ recipe.name }}</title>
    <link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='style.css') }}">
</head>
<body>
    <div class="container">
        <h1>{{ recipe.name }}</h1>
        <h2>Ingredients</h2>
        <ul>
            {% for ingredient in recipe.ingredients %}
                <li>{{ ingredient.name }}: {{ ingredient.amount }}</li>
            {% endfor %}
        </ul>
        <h2>Steps</h2>
        <ol>
            {% for step in recipe.steps %}
                <li>{{ step.step }}</li>
            {% endfor %}
        </ol>
        <a href="/">Back to search</a>
    </div>
</body>
</html>


